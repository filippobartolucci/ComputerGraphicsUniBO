<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Filippo Bartolucci" />
  <title>Relazione Computer Graphics</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
		padding: 50px;
		hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Relazione Computer Graphics</h1>
<p class="author">Filippo Bartolucci</p>
<p class="date">A.A. 2021-2022</p>
</header>
<h1 id="indice">Indice</h1>
<ul>
<li><a href="#progetto">Progetto</a></li>
<li><a href="#scene.js">Scena</a></li>
<li><a href="#camera.js">Camera</a></li>
<li><a href="#animated_camera.js">Animated Camera</a></li>
<li><a href="#mesh_obj.js">Mesh Obj</a></li>
<li><a href="#riferimenti">Riferimenti utilizzati</a></li>
</ul>
<hr />
<h1 id="progetto">Progetto</h1>
<p>Questo progetto è stato sviluppo come prova d’esame per il corso
“Computer Graphics A.A. 2021/2022”. L’obbiettivo è sviluppare una
“3D-WebApp” usando WebGL (HTML5, CSS e contesto webgl), linguaggio
JavaScript e OpenGL ES SL con browser Chrome.</p>
<figure>
<img src="scena1.png" alt="Rendering di una scena" />
<figcaption aria-hidden="true">Rendering di una scena</figcaption>
</figure>
<p>Il progetto sviluppato consiste in un’applicazione web che permette
di visualizzare alcune scene 3D composte da una serie di oggetti. I file
che lo compongono sono i seguenti:</p>
<ul>
<li><strong>scene.js:</strong> contiene la classe principale che
gestisce tutte le altre.</li>
<li><strong>camera.js:</strong> classe che si occupa di gestire la
camera e i suoi movimenti nello spazio</li>
<li><strong>animated_camera.js:</strong> camera 3D che si muove in
automatico lungo un arco di circonferenza</li>
<li><strong>mesh_obj:</strong> classe per la gestione delle mesh</li>
<li><strong>main:</strong> entry point del programma.</li>
</ul>
<p><a href="#indice">Torna all’indice</a></p>
<hr />
<h1 id="scene.js">scene.js</h1>
<p>Rappresenta la classe principale che si occupa di tutte le
operazioni, dalla inizializzazione del canvas e delle mesh al
rendering.</p>
<p>Quando viene creato un nuovo oggetto scena vengono eseguite le
seguenti operazioni:</p>
<ul>
<li>viene preso il WebGL rendering context dal canvas</li>
<li>impostazione delle dimensioni della viewport</li>
<li>compilazione di vertex e fragment shader</li>
<li>lettura di un <strong>file json</strong> per ottenere la lista delle
mesh da mostrare</li>
<li>per ogni elemento mesh nel file json viene creato un nuovo
<strong>mesh_obj</strong> e salvato in una lista</li>
<li>inizializzazione di <strong>camera</strong>, <strong>keys</strong>
(struttura per la gestione dei tasti della tastiera) e
<strong>light</strong> (oggetto luce di scena)</li>
</ul>
<p>L’utilizzo di una classe che contiene tutte le principali variabili
da utilizzare mi ha permesso di ridurre e semplificare il codice da
scrivere e poter usare le stesse variabili da passare alle mesh, senza
dover ricalcolare le stesse cose più volte.</p>
<p>Le mesh da visualizzare sono salvate in file json caricati al
momento. Questo mi ha permesso di creare un sistema più versatile, in
quanto posso creare scene diverse semplicemente creando più file
json.</p>
<p>Di seguito viene riportato un esempio di una scena con una mesh:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="er">&quot;meshes&quot;:</span><span class="ot">[</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;name&quot;</span><span class="fu">:</span><span class="st">&quot;mesh_1&quot;</span><span class="fu">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;obj_source&quot;</span><span class="fu">:</span><span class="st">&quot;./path/mesh.obj&quot;</span><span class="fu">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;mtl_source&quot;</span><span class="fu">:</span><span class="st">&quot;./path/mesh&quot;</span><span class="fu">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;position&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">0</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">]</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span></span></code></pre></div>
<p>Per ogni mesh nella lista vengono scritte le seguenti proprietà:</p>
<ul>
<li><strong>name:</strong> nome della mesh</li>
<li><strong>obj_source:</strong> path al file .obj</li>
<li><strong>mtl_source:</strong> path al file .mtl</li>
<li><strong>position:</strong> posizione della mesh</li>
</ul>
<h2 id="metodi">Metodi</h2>
<h3 id="async-load_mesh_jsonjson_path">async
load_mesh_json(json_path)</h3>
<p>Si occupa di leggere, in modo asincrono, un file json contenente gli
oggetti di scena; per ciascuno oggetto viene poi passato a un
costruttore di mesh_obj e salvato poi in
<code>scene.mesh_list</code>.</p>
<h3 id="projectionmatrix">projectionMatrix()</h3>
<p>Calcola la matrice di proiezione passando utilizzando la funzione
perspective della libreria m4.js.</p>
<h3 id="key_controller">key_controller(){</h3>
<p>Funzione che legge gli input da tastiera e chiama le funzioni di
movimento della camera a ogni tasto. La funzione è stata realizzata in
modo tale da permettere di fare più movimenti in contemporanea. Viene
richiamata ogni volta che deve essere disegnato un frame.</p>
<h3 id="switch_camera">switch_camera(){</h3>
<p>Passa dalla camera libera a quella animata e viceversa.</p>
<h3 id="async-prepareskybox">async prepareSkybox()</h3>
<p>Funzione che si occupare di caricare la cubemap texture per lo
skybox. Tutti i dati dello skybox sono salvati in
<code>scene.skybox</code>.</p>
<h3 id="toggle_skybox">toggle_skybox()</h3>
<p>Attiva o disattiva lo skybox cambiando il valore di
<code>scene.skybox.enable</code>. Se impostato a falso, la fase di
disegno dello skybox viene saltata.</p>
<h3 id="async-prepareshadow">async prepareShadow()</h3>
<p>Funzione che si occupa della preparazione dei dati per la gestione
delle ombre.</p>
<ul>
<li>compilazione shaders corrispondenti</li>
<li>creazione di una texture utilizzata come depth map</li>
<li>impostazione dei valori utilizzati in fase di rendering.</li>
</ul>
<h3 id="toggle_shadows">toggle_shadows()</h3>
<p>Passa dal programma shader con ombre a quello senza e viceversa.</p>
<h3 id="draw">draw()</h3>
<p>Funzione separata dalla classe Scene per questioni di scope. Esegue
le seguenti operazioni:</p>
<ul>
<li>ridimensiona canvas e viewport in base alla grandezza della
finestra.</li>
<li>chiama <code>scene.key_controller()</code> per la gestione degli
input da tastiera.</li>
<li>calcola la matrice di proiezione e vista.</li>
<li>la matrice di vista viene ottenuta da <code>scene.camera</code> che
può essere un oggetto <code>Camera</code> o
<code>Animated_Camera</code>.</li>
<li>a seconda del valore di <code>scene.shadow.enable</code>:
<ul>
<li>esegue il rendering della scena con ombre.</li>
<li>esegue il rendering della scena senza ombre.</li>
</ul></li>
<li>a seconda del valore di <code>scene.skybox.enable</code> disegna o
meno lo skybox.</li>
</ul>
<h3 id="rendering-base">Rendering base</h3>
<p>La scene disegnata con il rendering base ha queste
caratteristiche:</p>
<ul>
<li>supporto per texture e colori</li>
<li>luce diffusa</li>
<li>specular lightning</li>
</ul>
<figure>
<img src="base.png" title="Scena disegnata con rendering base"
alt="Rendering base" />
<figcaption aria-hidden="true">Rendering base</figcaption>
</figure>
<h3 id="rendering-con-ombre">Rendering con ombre</h3>
<p>La tecnica di rendering avanzato che ho scelto per il mio progetto
sono le ombre, realizzate con tecnica di shadowmapping.</p>
<p>Per poter generare le ombre la scena viene disegnata due volta, prima
dal punto di vista della luce per generare una shadowmap, poi dal punto
di vista dell’osservatore utilizzando la shadowmap generata per capire
se un punto è in ombra o meno.</p>
<figure>
<img src="ombre.png" title="Stessa scena disegnata con le obre"
alt="Rendering con ombre" />
<figcaption aria-hidden="true">Rendering con ombre</figcaption>
</figure>
<p><a href="#indice">Torna all’indice</a></p>
<hr />
<h1 id="camera.js">camera.js</h1>
<p>Uno delle due camera utilizzabili per vedere la scena. Questa
permette un movimento nelle spazio 3D libero. L’orientamento della
camera è definito da tre assi ortogonali, in cui ogni asse è un vettore
in coordinate globali.</p>
<ul>
<li><strong>position:</strong> posizione nello spazio della camera.</li>
<li><strong>forward:</strong> vettore che punta davanti la camera.</li>
<li><strong>right:</strong> vettore che punta alla destra della
camera.</li>
<li><strong>up:</strong> vettore che punta verso l’alto.</li>
</ul>
<h2 id="metodi-1">Metodi</h2>
<h3 id="tiltstep">tilt(step)</h3>
<p>Ruota la visuale di una telecamera in alto o in basso. Il movimento
si ottiene sul vettore right.</p>
<h3 id="panstep">pan(step)</h3>
<p>Ruota la visuale della telecamera orizzontalmente rispetto alla
posizione dell’occhio della telecamera. Si ottiene ruotando il vettore
up.</p>
<h3 id="cantstep">cant(step)</h3>
<p>Inclina una telecamera lateralmente mantenendone la posizione e la
direzione di visualizzazione. Si ottiene ruotando il vettore
forward.</p>
<h3 id="truckdist">truck(dist)</h3>
<p>Sposta la posizione di una telecamera lateralmente (sinistra o
destra) mentre la direzione della visuale della telecamera è invariata.
Si ottiene sommando il vettore right, moltiplicato per
<code>dist</code>, alla posizione attuale della camera.</p>
<h3 id="pedestaldist">pedestal(dist)</h3>
<p>Eleva o abbassa la camera. Si ottiene sommando la posizione al
vettore up.</p>
<h3 id="dollystep">dolly(step)</h3>
<p>Avvicina o allontana una telecamera dalla posizione che sta
guardando. Risultato della somma della posizione con il vettore
forward.</p>
<h3 id="realign">realign()</h3>
<p>Riallinea la vista della camera con l’orizzonte.</p>
<h3 id="getviewmatrix">getViewMatrix()</h3>
<p>Calcola e restituisce la viewMatrix</p>
<h3 id="getposition">getPosition()</h3>
<p>Calcola e restituisce la viewMatrix</p>
<ul>
<li><a href="#indice">Torna all’indice</a></li>
</ul>
<hr />
<h1 id="animated_camera.js">animated_camera.js</h1>
<p>Secondo tipo di camera per visualizzare la scena, si muove in maniera
automatica lungo un quarto di circonferenza, rimanendo fissa a guardare
il centro della scena.</p>
<p>Per compatibilità, reimplementa tutti i metodi di
<code>camera.js</code>.</p>
<figure>
<img src="animated_camera.gif" title="Movimento in una scena"
alt="Movimento della camera" />
<figcaption aria-hidden="true">Movimento della camera</figcaption>
</figure>
<p>La posizione sulla circonferenza è determinata da due valori:</p>
<ul>
<li><strong>radius:</strong> rappresenta il raggio della circonferenza
sui cui ci si muove.</li>
<li><strong>angle:</strong> rappresenta l’angolo della posizione
attuale.</li>
</ul>
<p>Le coordinate x e z vengono ottenuto utilizzando le coordinate polari
con radius e angle.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">position</span>[<span class="dv">0</span>] <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">sin</span>(rad) <span class="op">*</span> <span class="kw">this</span><span class="op">.</span><span class="at">radius</span><span class="op">;</span>     <span class="co">// X</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">position</span>[<span class="dv">2</span>] <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">cos</span>(rad) <span class="op">*</span> <span class="kw">this</span><span class="op">.</span><span class="at">radius</span><span class="op">;</span>     <span class="co">// Z</span></span></code></pre></div>
<p>La ViewMatrix viene ottenuta con questa funzione:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">getViewMatrix</span>() {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span>#<span class="fu">move</span>()<span class="op">;</span>  <span class="co">// Funzione per aggiornare la posizione</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">const</span> look <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span>] <span class="co">// Direzione camera, rimane sempre fissa</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">const</span> cameraMatrix <span class="op">=</span> m4<span class="op">.</span><span class="fu">lookAt</span>(<span class="kw">this</span><span class="op">.</span><span class="at">position</span><span class="op">,</span> look<span class="op">,</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> m4<span class="op">.</span><span class="fu">inverse</span>(cameraMatrix)<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<ul>
<li><a href="#indice">Torna all’indice</a></li>
</ul>
<hr />
<h1 id="mesh_obj.js">mesh_obj.js</h1>
<p>Questa classe si occupa di tutti le funzionalità delle mesh visibili
in scena, dal loro caricamento al render. Il costruttore prende un
oggetto, ottenuto dalla lettura di un json in <code>scene.js</code>,
contenente tutte le impostazioni come:</p>
<ul>
<li>path per il file .obj</li>
<li>path per il file .mtl</li>
<li>posizione dell’ oggetto rispetto all’origine</li>
</ul>
<h2 id="metodi-2">Metodi</h2>
<h3 id="prepare_meshgl">prepare_mesh(gl)</h3>
<p>Funzione chiamata dal costruttore dopo che viene letto il file obj.
Si occupa della creazione dei buffer, utilizzando la funzione
<code>webglUtils.createBufferInfoFromArrays(gl, data)</code>, per le
varie componenti della mesh.</p>
<h3 id="rendergl-programinfo-uniforms">render(gl, programInfo,
uniforms)</h3>
<p>Funzione che disegna l’oggetto utilizzando il programma e le uniform
specificate nei parametri. Viene chiamata dalla funzione render che si
occupa di scegliere programInfo e uniform a seconda del tipo di
rendering scelto. Avendo program e uniforms parametrizzato la funzione
di rendering è unica per tutti le modalità di disegno.</p>
<ul>
<li><a href="#indice">Torna all’indice</a></li>
</ul>
<hr />
<h1 id="riferimenti">Riferimenti</h1>
<p>Per la realizzazione del progetto, oltre alle slide e al codice visto
durante il corso, ho fatto riferimento ai seguenti articoli:</p>
<ul>
<li><a
href="http://learnwebgl.brown37.net/07_cameras/camera_introduction.html">Learn
WebGL: Introduction to camera</a></li>
<li><a
href="https://webglfundamentals.org/webgl/lessons/webgl-3d-camera.html">WebGl
Fundamentals: 3D Camera</a></li>
<li><a
href="https://webglfundamentals.org/webgl/lessons/webgl-load-obj-w-mtl.html">WebGL
Fundamentals: Loading .obj with Mtl</a></li>
<li><a
href="https://webglfundamentals.org/webgl/lessons/webgl-shadows.html">WebGL
Fundamentals: Shadows</a></li>
</ul>
<h2 id="torna-allindice"><a href="#indice">Torna all’indice</a></h2>
</body>
</html>
